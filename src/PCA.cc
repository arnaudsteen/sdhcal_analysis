/// \file PCA.cc
/*
 *
 * PCA.cc source template generated by fclass
 * Creation date : ven. juil. 12 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */
#include <marlin/Global.h>
#include <marlin/Exceptions.h>

#include "PCA.hh"
#include <TMatrixDSym.h>
#include <TMatrixDSymEigen.h>

using namespace marlin; 

PCA::~PCA() {
  pcaRows.clear();
}


void PCA::Init() {
  eigenValues.Clear();
  eigenVectors.Clear();
}


void PCA::CheckConsistency() {
  if( pcaRows.empty() ) throw ParseException( " PCA row vector is empty " );  
}


void PCA::Execute(bool showResults) {
  std::vector<double> rowMeans(pcaRows.size(),0);
  TMatrixD covMatrix(pcaRows.size(),pcaRows.size());

  for( unsigned int r=0 ; r<pcaRows.size() ; r++ )
    rowMeans.at(r) = std::accumulate ( pcaRows.at(r).begin() , pcaRows.at(r).end() , 0.0 ) *1.0 / pcaRows.at(r).size();

  double matrixTrack=0;
  for( unsigned int entry=0 ; entry<pcaRows.at(0).size() ; entry++ ){
    for( unsigned int r1=0 ; r1<pcaRows.size() ; r1++ ){
      for( unsigned int r2=0 ; r2<=r1 ; r2++ ){
	covMatrix( r1 , r2 ) += ( pcaRows.at(r1).at(entry) - rowMeans.at(r1) )*( pcaRows.at(r2).at(entry) - rowMeans.at(r2) ) ;
	// Covariance matrix is symmetric
	covMatrix( r2 , r1 ) = covMatrix( r1 , r2 );
	if(r1==r2)matrixTrack+=( pcaRows.at(r1).at(entry) - rowMeans.at(r1) )*( pcaRows.at(r2).at(entry) - rowMeans.at(r2) ) ;
	// Method to calculate matrix tracks CHECKED already
      }
    }
  }
  for(unsigned int r1=0; r1<pcaRows.size(); r1++){
    for(unsigned int r2=0; r2<=r1; r2++){
      covMatrix(r1,r2)=covMatrix(r1,r2)/matrixTrack;
      covMatrix(r2,r1)=covMatrix(r1,r2);
    }
  }
  TMatrixDEigen matrixEigen(covMatrix);
  
  if(showResults){
    std::cout << "covariance matrix track before normalisation : " << matrixTrack << std::endl;
    std::cout << "covariance : " << std::endl;
    covMatrix.Print();
    std::cout << "eigen vectors : " << std::endl;
    matrixEigen.GetEigenVectors().Print();
    std::cout << "eigen valuess : " << std::endl;
    matrixEigen.GetEigenValuesRe().Print();
    getchar();
  }

  eigenValues.ResizeTo( pcaRows.size() );
  eigenVectors.ResizeTo( pcaRows.size() , pcaRows.size() );
  eigenValues = matrixEigen.GetEigenValuesRe();
  eigenVectors = matrixEigen.GetEigenVectors();

}


void PCA::End() 
{
  pcaRows.clear();
}

void PCA::AddRow( const Row &row ) 
{
  if( pcaRows.empty() ) pcaRows.push_back( row );
  else if(row.size() == pcaRows.at(0).size()) pcaRows.push_back( row );
  else throw ParseException( " PCA row has an incompatible size " );   
}
